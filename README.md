# Euclidean and Extended Euclidean Algorithm Implementation

## Objective
This project implements both the Euclidean Algorithm to compute the Greatest Common Divisor (GCD) of two integers and the Extended Euclidean Algorithm, which finds integer coefficients for Bézout's identity. The Extended Euclidean Algorithm is essential for computing modular inverses, a critical component in RSA cryptography.

## Skills Learned
- Understanding of number theory and greatest common divisor (GCD) calculations  
- Implementing both the Euclidean and Extended Euclidean Algorithms in Java  
- Applying modular arithmetic for cryptographic applications  
- Computing modular inverses for RSA encryption and key generation  
- Working with recursion and iterative approaches in algorithm design  

## Tools Used
- Java (for coding the algorithm)  
- Eclipse IDE (for development and debugging)  
- JUnit Testing (for verifying correctness of implementations)  

## Implementation Details
The program consists of multiple components:
1. Euclidean Algorithm Function: Computes the GCD of two numbers using recursion and iteration.  
2. Extended Euclidean Algorithm Function: Determines integer coefficients for Bézout's identity and finds modular inverses.  
3. Modular Inverse Calculator: Uses the Extended Euclidean Algorithm for modular arithmetic applications.  
4. RSA Key Generation Utility: Computes modular inverses for RSA cryptography.  
5. Input Handling Module: Reads input from the user or external files to test algorithm efficiency.  
6. Performance Analyzer: Compares iterative vs. recursive approaches for runtime efficiency.  

## Steps
1. Implement the Euclidean Algorithm for computing the GCD of two numbers.  
2. Extend it to the Extended Euclidean Algorithm to compute Bézout's coefficients.  
3. Apply the Extended Euclidean Algorithm to calculate modular inverses.  
4. Use modular inverses in RSA key generation and encryption.  
5. Test the algorithm using sample input cases and analyze execution performance.  
6. Compare iterative and recursive implementations for efficiency.  

---
